class ValidaCpf:

    def cpfValido(self, number):

         # comprimento inválido ou dígitos repetidos
        if len(number) != 11 or re.search(r"(\d)(\1{10})", number): return False
        

        for cycle in range(2):

            limitIndex = 9 if cycle == 0 else 10
            baseWeight = limitIndex + 1
            temp = 0

            for index in range(0, limitIndex):
                temp += int(number[index]) * (baseWeight - index)

            temp %= 11
            digito = 0 if temp < 2 else 11 - temp

            if digito != int(number[limitIndex]):
                return False

        return True


# main

ValidaCpf = ValidaCpf()

while True:

    print()
    print("-"*41)
    print("Digite os digitos do CPF [digite X para sair]")
    print("-"*41)
    try:
      cpf = int(input("? "))  
      # if cpf.upper() == "X": break
    except ValueError:
      print("Oops! Isso não é um número válido....")
    finally:
      print("\nCPF é " + ("Valido!" if ValidaCpf.cpfValido(cpf) else " I N V Á L I D O  !!!"))     
    if cpf.upper() == "X": break  
    
    
    
    
    
    --------------------------------------------------------------------------------------------
    
    
    
    
    import re, datetime

class CpfValidador:
  def __init__(self, cpf):
    self.cpf = cpf

  def cpf_valido(self):
    if not self.cpf:
      return False

    novo_cpf = self.verifica_digitos(self.cpf[:9])
    novo_cpf = self.verifica_digitos(novo_cpf)

    if novo_cpf == self.cpf:
      return True
    return False   

  @staticmethod
  def verifica_digitos(fatia_cpf):
    if not fatia_cpf:
      return False

    seq = fatia_cpf[0]*len(fatia_cpf)

    if seq == fatia_cpf:
      return False

    soma = 0
    for chave, multi in enumerate(range(len(fatia_cpf)+1, 1, -1)):
      soma += int(fatia_cpf[chave])*multi      

    resto = 11 - (soma%11)
    resto = resto if resto <= 9 else 0  
    return fatia_cpf + str(resto)



  @staticmethod
  def _so_numeros(cpf):
    return re.sub('[^0-9]', '', cpf)



# main
 



cpf = CpfValidador('81597037087')
if cpf.cpf_valido():
  print('CPF válido')
else:
  print('CPF inválido')


agora = datetime.datetime.now()
data_str = agora.strftime('%d/%m/%Y %H:%M')
print(data_str)           

    
    
--------------------------------------------------------------------------------------------------------



import os
from datetime import datetime

def valida_cpf(cpf):
    cpf = ''.join(filter(str.isdigit, cpf)) # remove caracteres não numéricos
    if len(cpf) != 11: # verifica se o CPF tem 11 dígitos
        raise ValueError("CPF deve conter 11 dígitos")
    if cpf in ['00000000000', '11111111111', '22222222222', '33333333333', '44444444444', '55555555555', '66666666666', '77777777777', '88888888888', '99999999999']:
        raise ValueError("CPF inválido")
    dig1 = 0
    dig2 = 0
    for i in range(9):
        dig1 += int(cpf[i]) * (10 - i)
        dig2 += int(cpf[i]) * (11 - i)
    digV1 = (dig1 % 11) % 10
    digV2 = (dig2 % 11) % 10
    if int(cpf[9]) != digV1 or int(cpf[10]) != digV2:
        raise ValueError("Dígitos verificadores inválidos")
    return True

def save_resultado(cpf):
    with open("resultado.txt", "a") as arquivo:
        arquivo.write("\nData e Hora: {}\n".format(datetime.now()))
        arquivo.write("CPF: {}\n".format(cpf))
        arquivo.write("Result: Valid\n")

def save_erro(cpf, error):
    with open("log.txt", "a") as arquivo:
        arquivo.write("\nData e Hora: {}\n".format(datetime.now()))
        arquivo.write("CPF: {}\n".format(cpf))
        arquivo.write("Resultado: Inválido\n")

if __name__ == '__main__':
    try:
        cpf = input("Informe o CPF: ")
        result = valida_cpf(cpf)
        save_resultado(cpf)
        print("CPF válido")
    except ValueError as e:
        save_erro(cpf, e)
        print(e) 
